# Matha
Here are the main ways to categorize programming languages:
By Execution Model:

Compiled - Translated to machine code before running (C, Rust, Go)
Interpreted - Executed line-by-line at runtime (Python, JavaScript, Ruby)
Hybrid - Compiled to bytecode, then interpreted (Java, C#)

By Programming Paradigms:

Imperative - Step-by-step instructions (C, Python)
Functional - Functions as first-class citizens, immutability (Haskell, Lisp)
Object-Oriented - Everything is objects with methods (Java, C++)
Logic - Declare facts and rules, let system find solutions (Prolog)
Declarative - Say what you want, not how to get it (SQL, HTML)

By Type Systems:

Static - Types checked at compile time (C++, Java, Rust)
Dynamic - Types checked at runtime (Python, JavaScript)
Strong - Strict type enforcement (Python, Java)
Weak - Loose type conversion (C, JavaScript)

By Memory Management:

Manual - Programmer manages memory (C, C++)
Garbage Collected - Automatic memory cleanup (Java, Python)
Reference Counted - Track object usage (Swift, Python uses both)

By Domain:

General Purpose - Good for many tasks (Python, Java)
Domain-Specific - Specialized for specific problems (SQL for databases, R for statistics)

For Matha, you're building a domain-specific language (inverse problems) that will likely be interpreted, dynamically typed, and probably imperative with some functional features. The key is choosing what fits your domain best!